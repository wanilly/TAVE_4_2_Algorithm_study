# 문제: 테이블 위에 다양한 포도주의 종류가 들어있다. 포도주를 시음하기 위해서는 다음과 같은 규칙이 있다.
# 1. 마신 후에는 원래의 위치에 두어야 하며, 그 잔을 선택하면 다 먹어야 한다. 연속으로 3잔을 마실 수 없음
# 포도주 잔을 고민을 하여야 하는데, 1부터 n까지 되어 있다. n개의 포도주 잔이 놓여있고, 각 포도주 잔의 양이 주어졌을 때, 가쟝 많은 양을 마실 수 있는 프로그램작성
# 예를 들면 포도주 잔이 6개가 있고, 각각의 순서대로 6, 10, 13, 9, 8, 1 만큼 양이 있을 떄, 첫번째, 두번째, 네번째, 다섯번째를 선택하면 마시는 총 양은 최대 33이다.
# 입력 - 첫째 줄에 포도주 잔의 개수 n이 주어진다. 둘째 줄부터 n+1번째 줄까지 포도주 잔에 들어있는 포도주의 양이 순서대로 주어진다. 포도주의 양은 1,000 이하의 음이 아닌 정수이다.
# 출력 - 최데로 마실 수 있는 양
# 접근법: 다이나믹 프로그래밍을 활용하고, 점화식을 만들자 n개의 잔을 마시는 경우를 생각해보면, 연속으로 3잔을 마실 수 없는 것을 생각해보면,
# n-1를 마시지 않은 경우, n-2를 고를 수 있다. / n-1를 마신 경우, n-2를 고르면 연속 3잔이 되기 때문에 조건을 만족할 수 없다.
# n번째 까지 마셨을 때 최대 시음의 양은 Dn으로 표시하고, 0번째 까지는 0이다. 1번째 까지는 6(Wn)으로 표시한다. 왜냐하면 각 포도주의 양을 Wn으로 표시한다.
# D2는 W1+W2, D3은 W1+W2, W2+W3, W1+W3 중의 최대값, 이유는 3잔을 연속으로 마실 수 없기 떄문에
# 최종식은 D3 = (D2, D1+W3,D0+W2, W3)
# n번째까지 최대로 마시는 양을 3가지로 볼 수 있다. 이번 차례에 마시지 않을 떄, Dn-1 / 이번에 마시고 바로 직전에 마시지 않을 떄, Dn + Wn-2 / 이번도 마시고 바로 직전에 마시고 그 전에 마시지 않을 때, Wn + Wn-1 + Dn-3

# 포도주 종류를 리스트에 담는다.
n = int(input())

# 초기화하기
w = [0]

for i in range(n):
    w.append(int(input()))

dp =[0]
# 여기서 append는 리스트에 순차적으로 보관하는 것이다.
dp.append(w[1])

# n번째 까지 포도주를 마시는 최대의 양을 식으로 표현
if n > 1:
    dp.append(w[1] + w[2])

# for문 루프를 돌면서 3보다 클 경우 최대로 마실 수 있는 양을 표현함, 대신 3잔을 연속으로 머실 수 없기 때문에 점화식
for i in range(3, 3+1):
    dp.append(max(dp[i-1], dp[i-3] + w[i-1] + w[i], dp[i-2] + w[i]))

print(dp[n])
