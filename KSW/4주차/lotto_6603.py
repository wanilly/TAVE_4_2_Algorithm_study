# 독일 로또는 {1, 2, ..., 49}에서 수 6개를 고른다. 로또 번호를 선택하는데 가장 유명한 전략은 49가지 수 중 k개의 수를 골라 집합 S를 만든 다음 그 수만 가지고 번호 선택
# 예를 들어, k = 8 S={1,2,3,5,8,13,21,24}인 경우 집합 S에서 수를 고를 수 있는 경우는 총 28가지이다. S, k가 주어졌을 때, 수를 고르는 모든 방법 구하는 프로그램 작성
# [1, 2, 3, 5, 8, 13] [1, 2, 3, 5, 8, 21] [1, 2, 3, 5, 8, 34] [1,2,3,5,13,21], ... , [3,5,8,13,21,34]
# 입력: 여러개의 테스트 케이스로 이루어져 있음, 각 테스트 케이스는 한줄, 첫 번째 수는 k이고 다음 k개 수는 S에 포함되는 수이다. S의 원소는 오름차순이다.
# 출력: 각 테스트 케이스마다 수를 구하는 모든 방법을 출력하고 사전 순으로 출력, 각 테스트 케이스 사이에는 빈 줄을 하나 출력한다. 각 테스트 사이에는 빈줄 하나 출력

# 접근법: 재귀함수로 풀수도 있고, 조합을 이용한 방법도 가능하다. 파이썬 itertools에 있는 combination을 이용한다.
# 백트레킹: dfs를 이용하되, 직전에 방문했던 노드보다 큰 값의 노드를 방문한다. 각 자리에 올 수 있는 원소는 s가 아니다.
# 예제 입력 7,1,2,3,4,5,6,7 입력 가정, 0번 인덱스의 숫자는 'k'에 해당하는 값이니 pop(0)으로 제거해주면 [1, 2, 3, 4, 5, 6, 7]이 남는다.
# 조합을 찾기 위해 첫 번째 자리의 값을 1로 선택하면 문제없이 여러 개의 조합을 찾아낼 수 있지만, 4로 선택 시 적절한 조합이 존재하지 않는다. 오름차순 선택
# i번째 자릿수라고 하면, arr배열에서 각 자릿수에 가능한 원소들의 인덱스는 [1 + i] ~ [k - 5+ (1 + i)]

from itertools import combinations
while True:
    a = input().splite()
    if a.pop(0) == '0': break
    for a in combinations(a, 6):
        print("".join(a))

    print()


# 백트레킹
# 함수실행하여 선택된 노드들이 표시될 T를 초기화시켜주고, DFS를 실행
def r_lot():
    global arr
    for i in arr(n):
        if i in T:
            continue
        else:
            if T[n - 1] > i:
                continue
            if < 5:
                T[n] = i
                r_lot(n+1, T)
                T[n+1] = 0
# r_lot 함수 재귀적으로 실행하여 6개 조합을 찾아냄
            else:
                print(' '.join(map(str, T[:-1])),end=' ')
                print(i)


def lotto():
    global arr
    for i in arr[0]:
        T = [0, 0, 0, 0, 0]
        T[0] = i
        r_lot(i, T)
