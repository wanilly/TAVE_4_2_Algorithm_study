# 철수의 토마토 농장에서는 토마토를 보관하는 큰 창고를 가지고 있다. 토마토는 아래의 그림과 같이 격자 모양 상자의 칸에 하나씩 넣어서 창고에 보관한다.
# 토마토들 중에는 잘 익은 것도 있지만, 아직 익지 않은 토마토들도 있을 수 있다. 보관 후 하루가 지나면, 익은 토마토들의 인접한 곳에 있는 익지 않은 토마토들은 익은 토마토의 영향을 받아 익게 된다.
# 하나의 토마토의 인접한 곳은 왼쪽, 오른쪽, 앞, 뒤 네 방향에 있는 토마토를 의미한다. 대각선 방향에 있는 토마토들에게는 영향을 주지 못하며, 토마토가 혼자 저절로 익는 경우는 없다고 가정한다.
# 철수는 창고에 보관된 토마토들이 며칠이 지나면 다 익게 되는지, 그 최소 일수를 알고 싶어 한다.
# 토마토를 창고에 보관하는 격자모양의 상자들의 크기와 익은 토마토들과 익지 않은 토마토들의 정보가 주어졌을 때, 며칠이 지나면 토마토들이 모두 익는지, 그 최소 일수를 구하는 프로그램을 작성하라.
# 단, 상자의 일부 칸에는 토마토가 들어있지 않을 수도 있다.
# 입력: 첫 줄에는 상자의 크기를 나타내는 두 정수 M,N이 주어진다. M은 상자의 가로 칸의 수, N은 상자의 세로 칸의 수를 나타낸다. 단, 2 ≤ M,N ≤ 1,000 이다.
# 둘째 줄부터는 하나의 상자에 저장된 토마토들의 정보가 주어진다. 즉, 둘째 줄부터 N개의 줄에는 상자에 담긴 토마토의 정보가 주어진다. 하나의 줄에는 상자 가로줄에 들어있는 토마토의 상태가 M개의 정수로 주어진다.
# 정수 1은 익은 토마토, 정수 0은 익지 않은 토마토, 정수 -1은 토마토가 들어있지 않은 칸을 나타낸다.
# 출력: 여러분은 토마토가 모두 익을 때까지의 최소 날짜를 출력해야 한다. 만약, 저장될 때부터 모든 토마토가 익어있는 상태이면 0을 출력해야 하고, 토마토가 모두 익지는 못하는 상황이면 -1을 출력해야 한다.

# 접근법: 간선 길이가 1인 그래프에서 최소 길이를 구하는 방법과 동일하다. BFS를 이용하면 된다.
# 토마토 배열을 입력 받고, 1은 이미 익은 토마토이므로 queue애 넣는다. 토마토 인접한 4(상하좌우)칸을 확인, 0인지 아닌지 확인하고 0이면 익힘
# 토마토 배열을 날짜 카운트(수) 배열로 보면, 첫날 익은 토마토 1, 다음날 익은 토마토 1+1, 또 그 다음날 익은 토마토 2+1 순으로 증가시킨다.
# 인접한 토마토를 모두 익혔으므로, 비어있는 칸(-1)으로 막혀있는 토마토는 익히지 못함, for문으로 확인해보면서 아직 익지 않은 토마토(0)가 있으면 -1을 출력하고 종료
# 익지 않은 토마토가 없으면, 배열에서 가장 큰 값을 출력한다. 이 값은 모든 토마토가 익은 마지막 날이다. 1부터 시작했으므로, 값에 -1을 빼야 한다.

import sys
from collections import deque

# queue에서 나온 현재 지점의 상하좌우를 탐색 /  x, y에서 각 좌표에 따라 더하고 빼주면 위쪽부터 시계방향으로 만든다.
dx = [-1, 0, 1, 0]
dy = [0, 1, 0, -1]

m, n = map(int, sys.stdin.readline().splite())

# deque를 사용하지 않고 list로 쓰면 시간초과가 뜬다. 맵에 저장하는데 a의 리스트 안에 1이면 q에 저장한다. => 1은 이미 익은 토마토
a = []
q = deque()
for i in range(n):
    a.append(list(map(int, sys.stdin.readline().splite())))
    for j in range(m):
        if a[i][j] == 1:
            q.append((i, j))

# deque는 스택과 큐의 기능을 모두 가진 객체로 출입구를 양쪽에 가지고 있다. 왼쪽에서 값을 빼고 싶으면 popleft()를 사용
def bfs():
    while q:
        x, y = q.popleft()
        for i in range(4):
            # dx와 dy의 배열을 통해 기존 x + dx[i] 와 y + dy[i]를 통해 다음에 갈 위치를 지정
            nx = x + dx[i]
            ny = y + dy[j]
            if nx < 0 or nx >= n or ny < 0 or ny >= m: # 2가지 조건을 주어져야 하는데, nx와 ny가 배열의 범위가 넘었는
            # 조건이 성립하면 실행하는 코드로 바꿀 수 있음 - if 0 <= nx < n and 0 <= ny < m and a[nx][ny] and not chk[nx][ny]:
                continue
            if a[nx][ny]: # 벽이 있는지, 이미 방문한 곳인지(여기서는 쓰지 않았다.)
                continue
            a[nx][ny] = a[x][y] + 1
            q.append((nx, ny))


# map을 순회하면서 최대값을 찾아 출력한다. 만약 안익은 토마토가 있다면 -1을 출력한다.
def sol():
    bfs()
    an = 0
    for i in range(n):
        if 0 in a[i]:
            return -1
        an = max(an, max(a[i]))
    return an-1

print(sol())
